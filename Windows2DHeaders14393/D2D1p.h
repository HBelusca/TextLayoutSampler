//---------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This file is automatically generated.  Please do not edit it directly.
//
// File name: D2D1p.h
//---------------------------------------------------------------------------
#ifdef _MSC_VER
#pragma once
#endif // #ifdef _MSC_VER

#ifndef _D2D1P_H_
#define _D2D1P_H_


#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _D2D1_3_H_
#include <D2D1_3.h>
#endif // #ifndef _D2D1_3_H_
#include <dxgidwm.h>

typedef interface IDebugLayer IDebugLayer;
        
#define D2D1_COMPOSITOR_MAX_LAYERS 3
#define D2D1_MAX_PRIMITIVE_PROPERTY_COUNT 7

/// <summary>
/// 2-bit value that controls antialiasing at a particular edge in a
/// rectangle/polygon.
/// </summary>
typedef enum D2D1_EDGE_FLAGS
{
    
    /// <summary>
    /// The edge will be rendered aliased, no ajustments
    /// </summary>
    D2D1_EDGE_FLAGS_NONE = 0x0,
    
    /// <summary>
    /// The edge will be rendered aliased, inset by 0.5 pixels in screen space
    /// </summary>
    D2D1_EDGE_FLAGS_INSET_BOTH = 0x1,
    
    /// <summary>
    /// The edge will be rendered aliased, extended by 0.5 pixels in screen space
    /// </summary>
    D2D1_EDGE_FLAGS_EXTEND_BOTH = 0x2,
    
    /// <summary>
    /// The edge will be rendered antialiased
    /// </summary>
    D2D1_EDGE_FLAGS_ANTIALIAS = 0x3,
    D2D1_EDGE_FLAGS_NONE_TOP = D2D1_EDGE_FLAGS_NONE << 0,
    D2D1_EDGE_FLAGS_INSET_BOTH_TOP = D2D1_EDGE_FLAGS_INSET_BOTH << 0,
    D2D1_EDGE_FLAGS_EXTEND_BOTH_TOP = D2D1_EDGE_FLAGS_EXTEND_BOTH << 0,
    D2D1_EDGE_FLAGS_ANTIALIAS_TOP = D2D1_EDGE_FLAGS_ANTIALIAS << 0,
    D2D1_EDGE_FLAGS_NONE_RIGHT = D2D1_EDGE_FLAGS_NONE << 8,
    D2D1_EDGE_FLAGS_INSET_BOTH_RIGHT = D2D1_EDGE_FLAGS_INSET_BOTH << 8,
    D2D1_EDGE_FLAGS_EXTEND_BOTH_RIGHT = D2D1_EDGE_FLAGS_EXTEND_BOTH << 8,
    D2D1_EDGE_FLAGS_ANTIALIAS_RIGHT = D2D1_EDGE_FLAGS_ANTIALIAS << 8,
    D2D1_EDGE_FLAGS_NONE_BOTTOM = D2D1_EDGE_FLAGS_NONE << 16,
    D2D1_EDGE_FLAGS_INSET_BOTH_BOTTOM = D2D1_EDGE_FLAGS_INSET_BOTH << 16,
    D2D1_EDGE_FLAGS_EXTEND_BOTH_BOTTOM = D2D1_EDGE_FLAGS_EXTEND_BOTH << 16,
    D2D1_EDGE_FLAGS_ANTIALIAS_BOTTOM = D2D1_EDGE_FLAGS_ANTIALIAS << 16,
    D2D1_EDGE_FLAGS_NONE_LEFT = D2D1_EDGE_FLAGS_NONE << 24,
    D2D1_EDGE_FLAGS_INSET_BOTH_LEFT = D2D1_EDGE_FLAGS_INSET_BOTH << 24,
    D2D1_EDGE_FLAGS_EXTEND_BOTH_LEFT = D2D1_EDGE_FLAGS_EXTEND_BOTH << 24,
    D2D1_EDGE_FLAGS_ANTIALIAS_LEFT = D2D1_EDGE_FLAGS_ANTIALIAS << 24,
    
    /// <summary>
    /// Antialias all 4 edges of a rectangle
    /// </summary>
    D2D1_EDGE_FLAGS_ANTIALIAS_RECTANGLE = (D2D1_EDGE_FLAGS_ANTIALIAS_TOP | D2D1_EDGE_FLAGS_ANTIALIAS_RIGHT | D2D1_EDGE_FLAGS_ANTIALIAS_BOTTOM | D2D1_EDGE_FLAGS_ANTIALIAS_LEFT),
    
    /// <summary>
    /// Alias all 4 edges of a rectangle
    /// </summary>
    D2D1_EDGE_FLAGS_ALIAS_RECTANGLE = (D2D1_EDGE_FLAGS_NONE_TOP | D2D1_EDGE_FLAGS_NONE_RIGHT | D2D1_EDGE_FLAGS_NONE_BOTTOM | D2D1_EDGE_FLAGS_NONE_LEFT),
    D2D1_EDGE_FLAGS_FORCE_DWORD = 0xffffffff

} D2D1_EDGE_FLAGS;

DEFINE_ENUM_FLAG_OPERATORS(D2D1_EDGE_FLAGS);


/// <summary>
/// Controls rendering of all primitives associated with a given
/// D2D1_COMPOSITOR_DRAWING_STATE.
/// </summary>
typedef enum D2D1_COMPOSITOR_DRAWING_STATE_OPTIONS
{
    D2D1_COMPOSITOR_DRAWING_STATE_OPTIONS_NONE = 0x00000000,
    
    /// <summary>
    /// Only render the interior portion of an antialiased shape
    /// </summary>
    D2D1_COMPOSITOR_DRAWING_STATE_OPTIONS_INTERIOR_ONLY = 0x00000001,
    
    /// <summary>
    /// Only render the exterior (antialiasing) portion of an antialaised shape
    /// </summary>
    D2D1_COMPOSITOR_DRAWING_STATE_OPTIONS_EXTERIOR_ONLY = 0x00000002,
    
    /// <summary>
    /// Writes to the depth buffer are enabled.
    /// </summary>
    D2D1_COMPOSITOR_DRAWING_STATE_OPTIONS_DEPTH_WRITE = 0x00000004,
    
    /// <summary>
    /// Reads from the depth buffer are enabled.
    /// </summary>
    D2D1_COMPOSITOR_DRAWING_STATE_OPTIONS_DEPTH_READ = 0x0000008,
    
    /// <summary>
    /// Indicates that alpha blending is not required as long as the following are all
    /// true: MaskInvert blend mode is not used.  The push-down opacity passed to
    /// DrawCompositorCommandList is 1.0.  This must not be specified if there is a
    /// color animation.
    /// </summary>
    D2D1_COMPOSITOR_DRAWING_STATE_OPTIONS_NO_BLENDING = 0x00000010,
    
    /// <summary>
    /// The batch does not contain rendering, instead it changes the clip rect.  Only
    /// the 1st primitive in the batch matters.  The transform and bounds are used to
    /// define an antialiased clipping rectangle.
    /// </summary>
    D2D1_COMPOSITOR_DRAWING_STATE_OPTIONS_CLIP_RECT = 0x00000020,
    D2D1_COMPOSITOR_DRAWING_STATE_OPTIONS_FORCE_DWORD = 0xffffffff

} D2D1_COMPOSITOR_DRAWING_STATE_OPTIONS;

DEFINE_ENUM_FLAG_OPERATORS(D2D1_COMPOSITOR_DRAWING_STATE_OPTIONS);


/// <summary>
/// Controls clipping behavior of edges in a clip polygon.
/// </summary>
typedef enum D2D1_POLYGON_EDGE_FLAG
{
    
    /// <summary>
    /// The next edge will be clipped.
    /// </summary>
    D2D1_POLYGON_EDGE_FLAG_NONE = 0x00000000,
    
    /// <summary>
    /// The next edge will not actually clip the geometry. The associated point only
    /// helps to define a future edge which may be clipped.
    /// </summary>
    D2D1_POLYGON_EDGE_FLAG_PLACEHOLDER = 0x00000001,
    D2D1_POLYGON_EDGE_FLAG_FORCE_DWORD = 0xffffffff

} D2D1_POLYGON_EDGE_FLAG;

DEFINE_ENUM_FLAG_OPERATORS(D2D1_POLYGON_EDGE_FLAG);


/// <summary>
/// Controls gradient pixel strip generation
/// </summary>
typedef enum D2D1_GRADIENT_PIXEL_USAGE
{
    
    /// <summary>
    /// Pixel strip is to be used to render a linear gradient.
    /// </summary>
    D2D1_GRADIENT_PIXEL_USAGE_LINEAR = 0x0,
    
    /// <summary>
    /// Pixel strip is to be used to render a radial gradient.
    /// </summary>
    D2D1_GRADIENT_PIXEL_USAGE_RADIAL = 0x1,
    D2D1_GRADIENT_PIXEL_USAGE_FORCE_DWORD = 0xffffffff

} D2D1_GRADIENT_PIXEL_USAGE;

DEFINE_ENUM_FLAG_OPERATORS(D2D1_GRADIENT_PIXEL_USAGE);


/// <summary>
/// Controls rendering of a compositor command list.
/// </summary>
typedef enum D2D1_DRAW_COMPOSITOR_COMMAND_LIST_OPTIONS
{
    D2D1_DRAW_COMPOSITOR_COMMAND_LIST_OPTIONS_NONE = 0x00000000,
    
    /// <summary>
    /// The MaskInvert blend mode is used (rather than SrcOver).
    /// </summary>
    D2D1_DRAW_COMPOSITOR_COMMAND_LIST_OPTIONS_MASK_INVERT = 0x00000001,
    
    /// <summary>
    /// The compositor command list should participate in the immediate-mode write-once
    /// rendering algorithm.
    /// </summary>
    D2D1_DRAW_COMPOSITOR_COMMAND_LIST_OPTIONS_WRITE_ONCE = 0x00000002,
    
    /// <summary>
    /// Use nearest-neighbor sampling rather than the sampling mode specified in the
    /// command list.
    /// </summary>
    D2D1_DRAW_COMPOSITOR_COMMAND_LIST_OPTIONS_FORCE_NEAREST_NEIGHBOR = 0x00000004,
    
    /// <summary>
    /// The min blend mode is used (rather than SrcOver).
    /// </summary>
    D2D1_DRAW_COMPOSITOR_COMMAND_LIST_OPTIONS_MIN_BLEND = 0x00000008,
    D2D1_DRAW_COMPOSITOR_COMMAND_LIST_OPTIONS_FORCE_DWORD = 0xffffffff

} D2D1_DRAW_COMPOSITOR_COMMAND_LIST_OPTIONS;

DEFINE_ENUM_FLAG_OPERATORS(D2D1_DRAW_COMPOSITOR_COMMAND_LIST_OPTIONS);


/// <summary>
/// Describes the memory used by image textures and shaders.
/// </summary>
typedef struct D2D1_RESOURCE_USAGE
{
    
    /// <summary>
    /// The current maximum amount of texture memory to maintain before evicting caches.
    /// </summary>
    UINT64 maximumTextureMemory;
    
    /// <summary>
    /// An approximate amount of memory used by cached textures.
    /// </summary>
    UINT64 textureMemory;

} D2D1_RESOURCE_USAGE;


/// <summary>
/// Defines how a bitmap is sampled when rendering a particular primitive.
/// </summary>
typedef struct D2D1_COMPOSITOR_BITMAP_BRUSH
{
    
    /// <summary>
    /// Mapping from primitive space to texture coordinates.
    /// </summary>
    D2D1_MATRIX_3X2_F primitiveToTexCoord;
    
    /// <summary>
    /// The subrect of the source bitmap that sampling should be limited to. This does
    /// not include the gutters around the bitmap. This rectangle is in normalized
    /// texture coordinate space.
    /// </summary>
    D2D1_RECT_F texCoordSubrect;

} D2D1_COMPOSITOR_BITMAP_BRUSH;


/// <summary>
/// Defines a bitmap which is used to render a set of primitives.
/// </summary>
typedef struct D2D1_COMPOSITOR_BITMAP
{
    
    /// <summary>
    /// Index of the bitmap to sample from.
    /// </summary>
    UINT32 bitmapIndex;
    
    /// <summary>
    /// The interpolation mode to use when sampling the bitmap.
    /// </summary>
    D2D1_INTERPOLATION_MODE interpolationMode;
    
    /// <summary>
    /// The horizontal extend mode to use when sampling the bitmap.
    /// </summary>
    D2D1_EXTEND_MODE extendModeX;
    
    /// <summary>
    /// The vertical extend mode to use when sampling the bitmap.
    /// </summary>
    D2D1_EXTEND_MODE extendModeY;

} D2D1_COMPOSITOR_BITMAP;


/// <summary>
/// The rendering state applied to 1 layer in a group of primitives.
/// </summary>
typedef struct D2D1_COMPOSITOR_LAYER_DRAWING_STATE
{
    
    /// <summary>
    /// TRUE if pixel shaders do not need to respect the solid color component.
    /// </summary>
    BOOL solidColorOptional;
    
    /// <summary>
    /// Optional color bitmap applied to each primitive.
    /// </summary>
    D2D1_COMPOSITOR_BITMAP colorBitmap;
    
    /// <summary>
    /// Optional opacity bitmap applied to each primitive.
    /// </summary>
    D2D1_COMPOSITOR_BITMAP opacityBitmap;

} D2D1_COMPOSITOR_LAYER_DRAWING_STATE;


/// <summary>
/// The rendering state applied to a group of primitives.
/// </summary>
typedef struct D2D1_COMPOSITOR_DRAWING_STATE
{
    
    /// <summary>
    /// The numbers of layers which affect this primitive.
    /// </summary>
    UINT32 layerCount;
    
    /// <summary>
    /// Flags which control rendering of all primitives associated with this state
    /// object.
    /// </summary>
    D2D1_COMPOSITOR_DRAWING_STATE_OPTIONS options;
    
    /// <summary>
    /// Offset into the primitive property array.
    /// </summary>
    UINT32 primitivePropertyOffset;
    
    /// <summary>
    /// Number of valid elements in the primitive property array after
    /// primitivePropertyOffset.
    /// </summary>
    UINT32 numPrimitiveProperties;
    
    /// <summary>
    /// Byte offset into primitive buffer of the first primitive.
    /// </summary>
    UINT32 primitiveStartOffset;
    
    /// <summary>
    /// Number of primitives in the primitive buffer to read.
    /// </summary>
    UINT32 primitiveCount;
    
    /// <summary>
    /// Reserved for internal D2D use.
    /// </summary>
    UINT32 firstVertexOffset;
    
    /// <summary>
    /// Reserved for internal D2D use.
    /// </summary>
    UINT32 firstIndex;
    
    /// <summary>
    /// Reserved for internal D2D use.
    /// </summary>
    UINT32 numIndices;
    
    /// <summary>
    /// Per-layer state.
    /// </summary>
    D2D1_COMPOSITOR_LAYER_DRAWING_STATE layers[3];

} D2D1_COMPOSITOR_DRAWING_STATE;


/// <summary>
/// Defines drawing state associated with 1 layer of 1 primitive.
/// </summary>
typedef struct D2D1_COMPOSITOR_PRIMITIVE_LAYER_STATE
{
    
    /// <summary>
    /// Straight color.
    /// </summary>
    D2D1_COLOR_F color;
    
    /// <summary>
    /// Color brush parameters.  Only used if there is a color bitmap bound.
    /// </summary>
    D2D1_COMPOSITOR_BITMAP_BRUSH colorBrush;
    
    /// <summary>
    /// Opacity brush parameters.  Only used if there is an opacity bitmap bound.
    /// </summary>
    D2D1_COMPOSITOR_BITMAP_BRUSH opacityBrush;
    
    /// <summary>
    /// Index of the primitive properties object to use.  Note that
    /// primitivePropertyOffset from the batch state is added to this value as well.
    /// Use UINT_MAX to specify that no primitive properties should apply.
    /// </summary>
    UINT32 primitivePropertiesIndex;

} D2D1_COMPOSITOR_PRIMITIVE_LAYER_STATE;


/// <summary>
/// Defines drawing state associated with 1 primitive..
/// </summary>
typedef struct D2D1_COMPOSITOR_PRIMITIVE_DRAWING_STATE
{
    
    /// <summary>
    /// Rectangular coordinates of the primitive.
    /// </summary>
    D2D1_RECT_F rect;
    
    /// <summary>
    /// Mapping from primitive space to command list space.
    /// </summary>
    D2D1_MATRIX_3X2_F transform;
    
    /// <summary>
    /// Per-primitive depth value (relative to the first primitive in the command list).
    /// </summary>
    FLOAT depth;
    
    /// <summary>
    /// Per-edge control of antialiasing..
    /// </summary>
    D2D1_EDGE_FLAGS edgeFlags;

} D2D1_COMPOSITOR_PRIMITIVE_DRAWING_STATE;

typedef struct D2D1_DEVICE_CONTEXT_BATCHING_STATE
{
    
    /// <summary>
    /// TRUE if the drawing context is in-between BeginDraw/EndDraw.
    /// </summary>
    BOOL isDrawing;
    
    /// <summary>
    /// TRUE if the layer/clip stack is not empty.
    /// </summary>
    BOOL clipStackHasContent;

} D2D1_DEVICE_CONTEXT_BATCHING_STATE;

typedef enum D2D1_INK_RENDERING_HINT
{
    
    /// <summary>
    /// Prefer a rendering algorithm that balances speed and quality.
    /// </summary>
    D2D1_INK_RENDERING_HINT_DEFAULT = 0,
    
    /// <summary>
    /// Prefer a rendering algorithm that optimizes for speed.
    /// </summary>
    D2D1_INK_RENDERING_HINT_LOW_LATENCY = 1,
    
    /// <summary>
    /// Prefer a rendering algorithm that optimizes for quality.
    /// </summary>
    D2D1_INK_RENDERING_HINT_HIGH_QUALITY = 2,
    D2D1_INK_RENDERING_HINT_FORCE_DWORD = 0xffffffff

} D2D1_INK_RENDERING_HINT;

typedef enum D2D1_PRIVATE_DEVICE_OPTIONS
{
    D2D1_PRIVATE_DEVICE_OPTIONS_NONE = 0,
    D2D1_PRIVATE_DEVICE_OPTIONS_DISABLE_PIXEL_COUNTING = 1,
    D2D1_PRIVATE_DEVICE_OPTIONS_ENABLE_PIXEL_COUNTING = 2,
    D2D1_PRIVATE_DEVICE_OPTIONS_FORCE_DWORD = 0xffffffff

} D2D1_PRIVATE_DEVICE_OPTIONS;


/// <summary>
/// Events logged during encoding of D2D images
/// </summary>
typedef enum D2D1_ENCODE_EVENT
{
    D2D1_ENCODE_EVENT_INITIAL_RENDER_COPY_FLUSH = 0,
    D2D1_ENCODE_EVENT_STRIP_INITIAL_RENDER_COPY_FLUSH = 1,
    D2D1_ENCODE_EVENT_STRIP_FINAL_RENDER_COPY_FLUSH = 2,
    D2D1_ENCODE_EVENT_STRIP_RENDER_FLUSH = 3,
    D2D1_ENCODE_EVENT_STRIP_MAP_BEGIN = 4,
    D2D1_ENCODE_EVENT_STRIP_MAP_END = 5,
    D2D1_ENCODE_EVENT_FORCE_DWORD = 0xffffffff

} D2D1_ENCODE_EVENT;


/// <summary>
/// Indicates the type of a pencil segment.  Large arcs are greater than 180
/// degrees, and small arcs are less.  Arcs near 180 degrees may specify either.
/// </summary>
typedef enum D2D1_PENCIL_SEGMENT_TYPE
{
    D2D1_PENCIL_SEGMENT_TYPE_CLOCKWISE_SMALL_ARC = 0x00000000,
    D2D1_PENCIL_SEGMENT_TYPE_CLOCKWISE_LARGE_ARC = 0x00000001,
    D2D1_PENCIL_SEGMENT_TYPE_COUNTER_CLOCKWISE_SMALL_ARC = 0x00000002,
    D2D1_PENCIL_SEGMENT_TYPE_COUNTER_CLOCKWISE_LARGE_ARC = 0x00000003,
    D2D1_PENCIL_SEGMENT_TYPE_LINE = 0x00000004,
    D2D1_PENCIL_SEGMENT_TYPE_FORCE_DWORD = 0xffffffff

} D2D1_PENCIL_SEGMENT_TYPE;


/// <summary>
/// Represents a point, pressure pair that makes up part of a D2D1_PENCIL_SEGMENT
/// </summary>
typedef struct D2D1_PENCIL_POINT
{
    FLOAT x;
    FLOAT y;
    FLOAT pressure;

} D2D1_PENCIL_POINT;


/// <summary>
/// Represents a segment to be used in the creation of an ID2D1PencilStroke object.
/// arcRadius is ignored when type is D2D1_PENCIL_SEGMENT_TYPE_LINE.
/// </summary>
typedef struct D2D1_PENCIL_SEGMENT
{
    D2D1_PENCIL_POINT endPoint;
    FLOAT arcRadius;
    D2D1_PENCIL_SEGMENT_TYPE type;

} D2D1_PENCIL_SEGMENT;


/// <summary>
/// Represents options for converting the pencil output to blended colors.
/// </summary>
typedef struct D2D1_PENCIL_BLEND_OPTIONS
{
    
    /// <summary>
    /// The opacity of a color which will logically be blended N times to the render
    /// target, where N is controlled by weightToBlendCount below. The default value is
    /// 0.2.
    /// </summary>
    FLOAT blendOpacity;
    
    /// <summary>
    /// This value is multiplied by coverage before the result is adjusted using
    /// blendOpacity and then blended. The default value is 1.0.
    /// </summary>
    FLOAT weightToBlendCount;

} D2D1_PENCIL_BLEND_OPTIONS;


/// <summary>
/// Defines the appearance of D2D pencil strokes.
/// </summary>
typedef struct D2D1_PENCIL_STYLE
{
    
    /// <summary>
    /// The radius of the stroke
    /// </summary>
    FLOAT radius;
    
    /// <summary>
    /// The color of the stroke. The alpha in this color is ignored; See
    /// D2D1_PENCIL_BLEND_OPTIONS
    /// </summary>
    D2D1_COLOR_F color;
    
    /// <summary>
    /// The amount of translation applied to the first of two paper textures per the
    /// amount of stroke distance
    /// </summary>
    FLOAT textureTranslationPerStrokeDistance;
    
    /// <summary>
    /// Options for how pencil strokes build and blend with content underneath them.
    /// </summary>
    D2D1_PENCIL_BLEND_OPTIONS blendOptions;

} D2D1_PENCIL_STYLE;


/// <summary>
/// Represents start and segment data within an ink stroke
/// </summary>
typedef struct D2D1_INK_STROKE_DATA
{
    _Field_size_(startPointSize) CONST BYTE *startPoint;
    
    /// <summary>
    /// The size of the start point.
    /// </summary>
    UINT32 startPointSize;
    
    /// <summary>
    /// Segments beginning at the start of the group.
    /// </summary>
    _Field_size_(segmentElementSize * segmentCount) CONST BYTE *segments;
    
    /// <summary>
    /// The size of each segment.
    /// </summary>
    UINT32 segmentElementSize;
    UINT32 segmentCount;

} D2D1_INK_STROKE_DATA;


/// <summary>
/// Indicates the type of an ink segment.  Large arcs are greater than 180 degrees,
/// and small arcs are less.  Arcs near 180 degrees may specify either.
/// </summary>
typedef enum D2D1_INK_SEGMENT_TYPE
{
    D2D1_INK_SEGMENT_TYPE_CLOCKWISE_SMALL_ARC = 0x00000000,
    D2D1_INK_SEGMENT_TYPE_CLOCKWISE_LARGE_ARC = 0x00000001,
    D2D1_INK_SEGMENT_TYPE_COUNTER_CLOCKWISE_SMALL_ARC = 0x00000002,
    D2D1_INK_SEGMENT_TYPE_COUNTER_CLOCKWISE_LARGE_ARC = 0x00000003,
    D2D1_INK_SEGMENT_TYPE_LINE = 0x00000004,
    D2D1_INK_SEGMENT_TYPE_FORCE_DWORD = 0xffffffff

} D2D1_INK_SEGMENT_TYPE;


/// <summary>
/// Base structure for ink segments.  This data is followed by an array of FLOAT
/// values of length specified using
/// ID2D1PrivateInkingFactory::RegisterInkStrokeFormat
/// </summary>
typedef struct D2D1_INK_SEGMENT_BASE
{
    D2D1_INK_SEGMENT_TYPE type;
    FLOAT arcRadius;
    D2D1_POINT_2F endPoint;

} D2D1_INK_SEGMENT_BASE;


/// <summary>
/// Structure for ink segments of format GUID_InkSegmentTypeTime
/// </summary>
typedef struct D2D1_INK_SEGMENT_TIME
{
    D2D1_INK_SEGMENT_BASE base;
    FLOAT time;

} D2D1_INK_SEGMENT_TIME;


/// <summary>
/// Structure for ink segments of format GUID_InkSegmentTypePressureTilt
/// </summary>
typedef struct D2D1_INK_SEGMENT_PRESSURE_TILT
{
    D2D1_INK_SEGMENT_BASE base;
    FLOAT pressure;
    FLOAT tiltX;
    FLOAT tiltY;

} D2D1_INK_SEGMENT_PRESSURE_TILT;


namespace D2D1{

COM_DECLSPEC_NOTHROW
D2D1FORCEINLINE
D2D1_PENCIL_BLEND_OPTIONS
PencilBlendOptions(
    FLOAT blendOpacity = 0.2f,
    FLOAT weightToBlendCount = 1.0f
    )
{
    D2D1_PENCIL_BLEND_OPTIONS options = { blendOpacity, weightToBlendCount };

    return options;
}

COM_DECLSPEC_NOTHROW
D2D1FORCEINLINE
D2D1_PENCIL_STYLE
PencilStyle(
    FLOAT radius,
    D2D1_COLOR_F color = D2D1::ColorF(0,0,0,1),
    FLOAT textureTranslationPerStrokeDistance = 0.1f,
    D2D1_PENCIL_BLEND_OPTIONS blendOptions = D2D1::PencilBlendOptions()
    )
{
    D2D1_PENCIL_STYLE style = { radius, color, textureTranslationPerStrokeDistance, blendOptions };

    return style;
}

} // namespace D2D1

// {58EB6E2A-D779-4b7d-AD39-6F5A9FC9D288}
DEFINE_GUID(CLSID_D2D1DirectionalBlurKernel, 0x58eb6e2a, 0xd779, 0x4b7d, 0xad, 0x39, 0x6f, 0x5a, 0x9f, 0xc9, 0xd2, 0x88);

//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_DIRECTIONALBLURKERNEL_PROP
//
//  Synopsis:
//      The enumeration of the Directional Blur Kernel effect's top level properties.
//
//------------------------------------------------------------------------------
typedef enum D2D1_DIRECTIONALBLURKERNEL_PROP
{
        
        //
        // Property Name: StandardDeviation
        // Property Type: FLOAT
        //
        D2D1_DIRECTIONALBLURKERNEL_PROP_STANDARD_DEVIATION = 0,
        
        //
        // Property Name: Direction
        // Property Type: D2D1_DIRECTIONALBLURKERNEL_DIRECTION
        //
        D2D1_DIRECTIONALBLURKERNEL_PROP_DIRECTION = 1,
        
        //
        // Property Name: KernelRangeFactor
        // Property Type: FLOAT
        //
        D2D1_DIRECTIONALBLURKERNEL_PROP_KERNEL_RANGE_FACTOR = 2,
        
        //
        // Property Name: OptimizationTransform
        // Property Type: D2D1_DIRECTIONALBLURKERNEL_OPTIMIZATION_TRANSFORM
        //
        D2D1_DIRECTIONALBLURKERNEL_PROP_OPTIMIZATION_TRANSFORM = 3,
        D2D1_DIRECTIONALBLURKERNEL_PROP_FORCE_DWORD = 0xffffffff

} D2D1_DIRECTIONALBLURKERNEL_PROP;


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_DIRECTIONALBLURKERNEL_DIRECTION
//
//------------------------------------------------------------------------------
typedef enum D2D1_DIRECTIONALBLURKERNEL_DIRECTION
{
        D2D1_DIRECTIONALBLURKERNEL_DIRECTION_HORIZONTAL = 0,
        D2D1_DIRECTIONALBLURKERNEL_DIRECTION_VERTICAL = 1,
        D2D1_DIRECTIONALBLURKERNEL_DIRECTION_FORCE_DWORD = 0xffffffff

} D2D1_DIRECTIONALBLURKERNEL_DIRECTION;


//+-----------------------------------------------------------------------------
//
//  Enum:
//      D2D1_DIRECTIONALBLURKERNEL_OPTIMIZATION_TRANSFORM
//
//------------------------------------------------------------------------------
typedef enum D2D1_DIRECTIONALBLURKERNEL_OPTIMIZATION_TRANSFORM
{
        D2D1_DIRECTIONALBLURKERNEL_OPTIMIZATION_TRANSFORM_NONE = 0,
        D2D1_DIRECTIONALBLURKERNEL_OPTIMIZATION_TRANSFORM_HALF_SCALE_QUARTER_PIXEL_TRANSLATION = 1,
        D2D1_DIRECTIONALBLURKERNEL_OPTIMIZATION_TRANSFORM_FORCE_DWORD = 0xffffffff

} D2D1_DIRECTIONALBLURKERNEL_OPTIMIZATION_TRANSFORM;




#ifndef D2D_USE_C_DEFINITIONS


/// <summary>
/// Allows the original image stream to be extracted from a D2D bitmap that was
/// created from it.
/// </summary>
interface DX_DECLARE_INTERFACE("cf5cda95-d05b-4159-9caa-0940ff819ff6") ID2DImageStreamSource  : public IUnknown
{
    
    STDMETHOD_(void, GetSourceStream)(
        _Outptr_ IStream **stream 
        ) CONST PURE;
}; // interface ID2DImageStreamSource


/// <summary>
/// A depth buffer used for write-once rendering.
/// </summary>
interface DX_DECLARE_INTERFACE("c164552d-7976-4fac-8a80-541309906e1f") ID2D1PrivateDepthBuffer  : public ID2D1Resource
{
}; // interface ID2D1PrivateDepthBuffer


/// <summary>
/// Controls the lifetime of a compositor command list buffer.
/// </summary>
interface DX_DECLARE_INTERFACE("1f3047e9-192e-4d40-b9c8-ccd90958ace5") ID2D1PrivateCompositorBuffer  : public IUnknown
{
    
    /// <summary>
    /// Returns a pointer to the buffer.
    /// </summary>
    STDMETHOD_(PVOID, GetBufferPointer)(
        ) PURE;
    
    /// <summary>
    /// Returns the buffer size (in bytes).
    /// </summary>
    STDMETHOD_(UINT32, GetBufferSize)(
        ) PURE;
}; // interface ID2D1PrivateCompositorBuffer


/// <summary>
/// Allows callout render.
/// </summary>
interface DX_DECLARE_INTERFACE("ca09578a-4f49-4ae1-8d03-75551c7d0c8d") ID2D1PrivateCompositorRenderer  : public IUnknown
{
    
    /// <summary>
    /// Tells the Private Renderer it is time to execute.
    /// </summary>
    STDMETHOD(Render)(
        ) PURE;
}; // interface ID2D1PrivateCompositorRenderer


interface DX_DECLARE_INTERFACE("46fdbfea-53f8-440c-b9e2-81dfec612a72") ID2D1PrivateDevice  : public IUnknown
{
    
    /// <summary>
    /// Returns the current resource usage for resources not directly under the
    /// application's control.
    /// </summary>
    STDMETHOD_(void, GetResourceUsage)(
        _Out_ D2D1_RESOURCE_USAGE *resourceUsage 
        ) CONST PURE;
    
    /// <summary>
    /// Flushes the D3D immediate device context (after first acquiring the D2D factory
    /// lock, if necessary).
    /// </summary>
    STDMETHOD_(void, FlushD3DDevice)(
        ) PURE;
    
    /// <summary>
    /// An extension of the public ClearResources API allowing the caller to retain a
    /// certain amount of memory usage.
    /// </summary>
    STDMETHOD_(void, ClearResources)(
        UINT32 millisecondsSinceUse = 0,
        UINT64 desiredResourceUsage = 0,
        _Out_opt_ BOOL *finalResourceUsageWithinDesiredSize = NULL 
        ) PURE;
    
    /// <summary>
    /// A variant of the public ClearResources API that clears all protected resources,
    /// regardless of their longevity.
    /// </summary>
    STDMETHOD_(void, ClearProtectedResources)(
        ) PURE;
    
    STDMETHOD(CreateDepthBuffer)(
        D2D1_SIZE_U pixelSize,
        BOOL hardwareProtected,
        _COM_Outptr_ ID2D1PrivateDepthBuffer **depthBuffer 
        ) PURE;
    
    /// <summary>
    /// Controls whether map on default texture is allowed, for testing purposes
    /// </summary>
    STDMETHOD_(void, SetMapDefaultTextureEnabled)(
        BOOL fEnabled 
        ) PURE;
    
    STDMETHOD_(void, LogEncodeEvent)(
        D2D1_ENCODE_EVENT type,
        _In_opt_ ID2D1Image *pImage,
        D2D1_RECT_L rect 
        ) CONST PURE;
    
    STDMETHOD_(void, SetPrivateDxgiFormatSupportOverrides)(
        _In_reads_(count) CONST DXGI_FORMAT *formats,
        _In_reads_(count) CONST UINT32 *supports,
        UINT32 count 
        ) PURE;
    
    /// <summary>
    /// Get the private device options specified on device creation.
    /// </summary>
    STDMETHOD_(D2D1_PRIVATE_DEVICE_OPTIONS, GetPrivateDeviceOptions)(
        ) PURE;
    
    /// <summary>
    /// Set pixel counting threshold: pass a pointer to the new threshold value to
    /// override the default value; pass a null pointer to restore the default value.
    /// </summary>
    STDMETHOD_(void, SetPixelCountingThreshold)(
        _In_opt_ CONST UINT32 *newThrehold 
        ) PURE;
}; // interface ID2D1PrivateDevice


interface DX_DECLARE_INTERFACE("6f72c0a2-6db7-46e9-9b62-b58a23f4928b") ID2D1PrivateFactory  : public IUnknown
{
    
    /// <summary>
    /// Creates a geometry from a set of rectangles.
    /// </summary>
    STDMETHOD(CreateGeometryFromRectangles)(
        _In_reads_(rectsCount) CONST D2D1_RECT_L *rects,
        UINT32 rectsCount,
        _COM_Outptr_ ID2D1Geometry **combinedGeometry 
        ) PURE;
    
    /// <summary>
    /// Combines 2 geometries into 1.
    /// </summary>
    STDMETHOD(CreateCombinedGeometry)(
        D2D1_COMBINE_MODE combineMode,
        _In_ ID2D1Geometry *geometry1,
        _In_opt_ CONST D2D1_MATRIX_3X2_F *transform1,
        _In_ ID2D1Geometry *geometry2,
        _In_opt_ CONST D2D1_MATRIX_3X2_F *transform2,
        FLOAT flatteningTolerance,
        _COM_Outptr_ ID2D1Geometry **combinedGeometry 
        ) PURE;
    
    /// <summary>
    /// Generates pixel data from a set of gradient stops
    /// </summary>
    STDMETHOD(GenerateGradientPixels)(
        _In_reads_(gradientStopsCount) CONST D2D1_GRADIENT_STOP *gradientStops,
        _In_range_(>=,1) UINT32 gradientStopsCount,
        D2D1_GRADIENT_PIXEL_USAGE gradientType,
        D2D1_COLOR_SPACE inputSpace,
        D2D1_COLOR_SPACE interpolationSpace,
        D2D1_COLOR_SPACE outputSpace,
        D2D1_EXTEND_MODE extendMode,
        D2D1_COLOR_INTERPOLATION_MODE colorInterpolationMode,
        DXGI_FORMAT dxgiPixelFormat,
        _Out_writes_bytes_(pixelArraySizeInBytes) void *pixelArray,
        UINT32 pixelArraySizeInBytes 
        ) PURE;
    
    /// <summary>
    /// Controls if D2D will offer/reclaim internal allocations.
    /// </summary>
    STDMETHOD_(void, ControlOfferReclaim)(
        BOOL enableOfferReclaim 
        ) PURE;
    
    /// <summary>
    /// Enables or disables the fast tessellator for opaque strokes.
    /// </summary>
    STDMETHOD_(void, SetFastStrokeTessellatorEnabled)(
        BOOL enable 
        ) PURE;
    
    /// <summary>
    /// Enables or disables DPI dependent sample-count optimizations.
    /// </summary>
    STDMETHOD_(void, SetDpiDependentOptimizationsEnabled)(
        BOOL enable 
        ) PURE;
    
    /// <summary>
    /// Sets options to affect rendering of primitives in visual verification test.
    /// </summary>
    STDMETHOD_(void, SetVisualVerificationTestFeatures)(
        BOOL renderWireframe,
        BOOL renderCoarseTessellation,
        FLOAT antialiasingAmplification 
        ) PURE;
    
    /// <summary>
    /// This globally registers the given effect as a parameterized effect. The effect
    /// can later be instantiated by using the registered class id. The effect
    /// registration is reference counted.
    /// </summary>
    STDMETHOD(RegisterParameterizedEffect)(
        _In_ REFCLSID classId,
        _In_reads_(shaderSize) CONST BYTE *shader,
        UINT32 shaderSize 
        ) PURE;
    
    STDMETHOD_(void, SetInternalDeviceCreationFlags)(
        UINT32 deviceCreationFlags 
        ) PURE;
    
    STDMETHOD_(UINT32, GetInternalDeviceCreationFlags)(
        ) CONST PURE;
    
    STDMETHOD_(void, SetEtwEnableBits)(
        UINT32 etwEnableBits 
        ) PURE;
    
    STDMETHOD_(UINT32, GetEtwEnableBits)(
        ) CONST PURE;
    
    /// <summary>
    /// This creates a new Direct2D private device from the given private device option
    /// and IDXGIDevice.
    /// </summary>
    STDMETHOD(CreatePrivateDevice)(
        D2D1_PRIVATE_DEVICE_OPTIONS deviceOptions,
        _In_ IDXGIDevice *dxgiDevice,
        _COM_Outptr_ ID2D1PrivateDevice **d2dPrivateDevice 
        ) PURE;
    
    /// <summary>
    /// Given a direct 3D format return the number of bytes need to store one pixel.
    /// Returns 0 for unsupported formats.
    /// </summary>
    STDMETHOD_(UINT, GetDXGIFormatSize)(
        DXGI_FORMAT format 
        ) CONST PURE;
}; // interface ID2D1PrivateFactory


interface DX_DECLARE_INTERFACE("e7fda62a-6a94-4f17-9f7c-26a950c74010") ID2D1RegionGeometry  : public ID2D1Geometry
{
    
    /// <summary>
    /// Returns the number of contained rectangles.
    /// </summary>
    STDMETHOD_(UINT32, GetRectangleCount)(
        ) CONST PURE;
    
    /// <summary>
    /// Returns the contained rectangles.
    /// </summary>
    STDMETHOD_(void, GetRectangles)(
        _Out_writes_to_(rectanglesCount, _Inexpressible_("Retrieved through GetRectangleCount()") ) D2D1_RECT_L *rectangles,
        UINT32 rectanglesCount 
        ) CONST PURE;
}; // interface ID2D1RegionGeometry


/// <summary>
/// A reference to properties of a particular primitive inside of a
/// ID2D1PrivateCompositorCommandList.
/// </summary>
interface DX_DECLARE_INTERFACE("5ff48bd3-3539-4508-bceb-939d5b99de9a") ID2D1PrivateCompositorPrimitiveProperties  : public ID2D1Resource
{
}; // interface ID2D1PrivateCompositorPrimitiveProperties


/// <summary>
/// A command list specialized for compositor usage only.
/// </summary>
interface DX_DECLARE_INTERFACE("e86eb2fc-5d0b-44b5-8a4e-0631db9efc5f") ID2D1PrivateCompositorCommandList  : public ID2D1Resource
{
    
    /// <summary>
    /// Replaces the bitmaps within the compositor command list. The new bitmaps must
    /// have the same properties as the old ones.
    /// </summary>
    STDMETHOD(SetBitmaps)(
        _In_reads_opt_(colorBitmapsCount) ID2D1Bitmap **colorBitmaps,
        UINT32 colorBitmapsCount,
        _In_reads_opt_(opacityBitmapsCount) ID2D1Bitmap **opacityBitmaps,
        UINT32 opacityBitmapsCount 
        ) PURE;
    
    /// <summary>
    /// Returns a new command list which is the same as this command list, but clipped
    /// to the given convex polygon.
    /// </summary>
    STDMETHOD(ClipToPolygon)(
        _In_reads_(pointsCount) CONST D2D1_POINT_2F *points,
        UINT32 pointsCount,
        _In_reads_opt_(edgeFlagsCount) CONST D2D1_POLYGON_EDGE_FLAG *edgeFlags,
        UINT32 edgeFlagsCount,
        _COM_Outptr_ ID2D1PrivateCompositorCommandList **clippedCommandList 
        ) PURE;
}; // interface ID2D1PrivateCompositorCommandList


/// <summary>
/// Device context methods used by a compositor only.
/// </summary>
interface DX_DECLARE_INTERFACE("2ea67ed7-d42e-4c07-9dd5-a91ea23e01d2") ID2D1PrivateCompositorDeviceContext  : public IUnknown
{
    
    /// <summary>
    /// Creates an empty compositor command list object.
    /// </summary>
    STDMETHOD(CreateCompositorCommandList)(
        _In_ ID2D1PrivateCompositorBuffer *commandBuffer,
        _In_ ID2D1PrivateCompositorBuffer *primitiveBuffer,
        _In_reads_opt_(colorBitmapsCount) ID2D1Bitmap **colorBitmaps,
        UINT32 colorBitmapsCount,
        _In_reads_opt_(opacityBitmapsCount) ID2D1Bitmap **opacityBitmaps,
        UINT32 opacityBitmapsCount,
        _In_reads_opt_(primitivePropertiesCount) ID2D1PrivateCompositorPrimitiveProperties **primitiveProperties,
        UINT32 primitivePropertiesCount,
        _COM_Outptr_ ID2D1PrivateCompositorCommandList **commandList 
        ) PURE;
    
    /// <summary>
    /// Renders a compositor command list. The command list must be closed. The target
    /// must be a bitmap. The supplied opacity is applied to each primitive in the
    /// command list individually. The perspective transform is appended to the existing
    /// transform on the D2D device context. Rendering is affected by the following
    /// states on the device context: Transform, Clips, Layers, Unit mode. Rendering is
    /// not affected by the following states: Antialias mode, Primitive blend
    /// </summary>
    STDMETHOD_(void, DrawCompositorCommandList)(
        _In_ ID2D1PrivateCompositorCommandList *commandList,
        FLOAT opacity,
        _In_opt_ CONST D2D1_MATRIX_4X4_F *perspectiveTransform,
        D2D1_DRAW_COMPOSITOR_COMMAND_LIST_OPTIONS options,
        UINT32 startCommandIndex 
        ) PURE;
    
    /// <summary>
    /// Creates a primitive properties API object. The default color is (1,1,1,1)
    /// </summary>
    STDMETHOD(CreatePrimitiveProperties)(
        _COM_Outptr_ ID2D1PrivateCompositorPrimitiveProperties **properties 
        ) PURE;
    
    /// <summary>
    /// Changes the color associated with a primitive inside of a compositor command
    /// list. The color change is batched along with other commands in the device
    /// context. This color is multiplied by the color specfied when the command list is
    /// created. The default color is (1,1,1,1). The drawing context must be inside of
    /// BeginDraw/EndDraw when this call is made.
    /// </summary>
    STDMETHOD_(void, SetPrimitiveColor)(
        _In_ ID2D1PrivateCompositorPrimitiveProperties *primitiveProperties,
        _In_ CONST D2D1_COLOR_F *color 
        ) PURE;
    
    /// <summary>
    /// Binds a target bitmap and depth buffer.
    /// </summary>
    STDMETHOD_(void, SetTargetAndDepthBuffer)(
        _In_opt_ ID2D1Image *image,
        _In_opt_ ID2D1PrivateDepthBuffer *depthBuffer 
        ) PURE;
    
    /// <summary>
    /// Returns the currently set depth buffer
    /// </summary>
    STDMETHOD_(void, GetDepthBuffer)(
        _Outptr_result_maybenull_ ID2D1PrivateDepthBuffer **depthBuffer 
        ) PURE;
    
    /// <summary>
    /// Notifies D2D of the D3D guard rectangle set on a bitmap.
    /// </summary>
    STDMETHOD_(void, SetGuardRect)(
        _In_ ID2D1Bitmap *bitmap,
        _In_opt_ CONST RECT *rect 
        ) PURE;
    
    /// <summary>
    /// Sets an axis-aligned clipping rectangle which applies to all primitives.
    /// </summary>
    STDMETHOD_(void, SetPrimitiveClip)(
        _In_opt_ CONST D2D1_RECT_F *clipRect,
        D2D1_ANTIALIAS_MODE antialiasMode 
        ) PURE;
    
    /// <summary>
    /// Determines if the device context is in-between BeginDraw/EndDraw, and determines
    /// if there are any clips/layers pushed on the device context.
    /// </summary>
    STDMETHOD_(void, QueryBatchingState)(
        _Out_ D2D1_DEVICE_CONTEXT_BATCHING_STATE *state 
        ) PURE;
    
    /// <summary>
    /// Creates a bitmap from another bitmap, while also creating a new clip / layer
    /// stack.  This is useful for bitmaps used as atlases.
    /// </summary>
    STDMETHOD(CreateSharedAtlasBitmap)(
        _In_ ID2D1Bitmap1 *bitmap,
        _In_opt_ CONST D2D1_BITMAP_PROPERTIES1 *bitmapProperties,
        _COM_Outptr_ ID2D1Bitmap1 **newBitmap 
        ) PURE;
    
    STDMETHOD(PresentDWM)(
        _In_ IDXGISwapChainDWM1 *pSwapChain,
        UINT32 SyncInterval,
        UINT32 Flags,
        _In_reads_opt_(dirtyRectsCount) CONST RECT *dirtyRects,
        UINT32 dirtyRectsCount,
        _In_reads_opt_(scrollRectsCount) CONST DXGI_SCROLL_RECT *scrollRects,
        UINT32 scrollRectsCount,
        _In_opt_ IDXGIResource *pSwapchainBufferOverride,
        UINT32 AbsoluteVSyncCount 
        ) PURE;
    
    STDMETHOD(PresentMultiplaneOverlay)(
        _In_ IDXGISwapChainDWM1 *pSwapChain,
        UINT32 SyncInterval,
        UINT32 Flags,
        DXGI_HDR_METADATA_TYPE HDRMetaDataType,
        _In_opt_ CONST void *pHDRMetaData,
        _In_reads_(presentPlanesCount) CONST DXGI_PRESENT_MULTIPLANE_OVERLAY *presentPlanes,
        UINT32 presentPlanesCount 
        ) PURE;
    
    /// <summary>
    /// Renders a set of compositor primitives.
    /// </summary>
    STDMETHOD_(void, DrawCompositorPrimitives)(
        _In_ ID2D1PrivateCompositorRenderer *pRenderer 
        ) PURE;
    
    /// <summary>
    /// Creates an empty compositor command list object.
    /// </summary>
    STDMETHOD(CreateCompositorCommandListWithBounds)(
        _In_ ID2D1PrivateCompositorBuffer *commandBuffer,
        _In_ ID2D1PrivateCompositorBuffer *primitiveBuffer,
        _In_reads_opt_(colorBitmapsCount) ID2D1Bitmap **colorBitmaps,
        UINT32 colorBitmapsCount,
        _In_reads_opt_(opacityBitmapsCount) ID2D1Bitmap **opacityBitmaps,
        UINT32 opacityBitmapsCount,
        _In_reads_opt_(primitivePropertiesCount) ID2D1PrivateCompositorPrimitiveProperties **primitiveProperties,
        UINT32 primitivePropertiesCount,
        _In_ CONST D2D1_RECT_F *bounds,
        _COM_Outptr_ ID2D1PrivateCompositorCommandList **commandList 
        ) PURE;
    
    STDMETHOD_(void, SetInkRenderingHint)(
        D2D1_INK_RENDERING_HINT inkRenderingHint 
        ) PURE;
    
    STDMETHOD_(D2D1_INK_RENDERING_HINT, GetInkRenderingHint)(
        ) CONST PURE;
}; // interface ID2D1PrivateCompositorDeviceContext


/// <summary>
/// Represents a single continuous stroke of pencil, as defined by a series of arc
/// segments.
/// </summary>
interface DX_DECLARE_INTERFACE("1ed5a7eb-dfdf-4d4a-aa5e-c531e5528792") ID2D1PencilStroke  : public ID2D1Resource
{
    
    /// <summary>
    /// Resets the start point
    /// </summary>
    STDMETHOD_(void, SetStartPoint)(
        _In_ CONST D2D1_PENCIL_POINT *startPoint 
        ) PURE;
    
    /// <summary>
    /// Gets the start point
    /// </summary>
    STDMETHOD_(D2D1_PENCIL_POINT, GetStartPoint)(
        ) CONST PURE;
    
    /// <summary>
    /// Resets the seed at the start point.  The default seed value is 0.0.
    /// </summary>
    STDMETHOD_(void, SetStartTextureTranslationSeed)(
        FLOAT startSeed 
        ) PURE;
    
    /// <summary>
    /// Gets the seed at the start point
    /// </summary>
    STDMETHOD_(FLOAT, GetStartTextureTranslationSeed)(
        ) CONST PURE;
    
    /// <summary>
    /// Adds one or more segments to the end of the pencil
    /// </summary>
    STDMETHOD(AddSegments)(
        _In_reads_(segmentsCount) CONST D2D1_PENCIL_SEGMENT *segments,
        UINT32 segmentsCount 
        ) PURE;
    
    /// <summary>
    /// Removes one or more segments from the end of the pencil
    /// </summary>
    STDMETHOD(RemoveSegmentsAtEnd)(
        UINT32 segmentCount 
        ) PURE;
    
    /// <summary>
    /// Updates the specified segments
    /// </summary>
    STDMETHOD(SetSegments)(
        UINT32 startSegment,
        _In_reads_(segmentsCount) CONST D2D1_PENCIL_SEGMENT *segments,
        UINT32 segmentsCount 
        ) PURE;
    
    /// <summary>
    /// Returns the number of segments the pencil is composed of
    /// </summary>
    STDMETHOD_(UINT32, GetSegmentCount)(
        ) CONST PURE;
    
    /// <summary>
    /// Retrieves the segments stored in the pencil
    /// </summary>
    STDMETHOD(GetSegments)(
        UINT32 startSegment,
        _Out_writes_(segmentsCount) D2D1_PENCIL_SEGMENT *segments,
        UINT32 segmentsCount 
        ) CONST PURE;
    
    /// <summary>
    /// Retrieves the bounds of the pencil, with an optional applied transform
    /// </summary>
    STDMETHOD(GetBounds)(
        _In_ CONST D2D1_PENCIL_STYLE *pencilStyle,
        _In_opt_ CONST D2D1_MATRIX_3X2_F *worldTransform,
        _Out_ D2D1_RECT_F *bounds 
        ) CONST PURE;
}; // interface ID2D1PencilStroke


/// <summary>
/// Creates and draws pencil strokes.
/// </summary>
interface DX_DECLARE_INTERFACE("fbf7424d-cda8-418e-a508-cd1e58a113fb") ID2D1PrivatePencilDeviceContext  : public IUnknown
{
    
    STDMETHOD(CreatePencilStroke)(
        _In_ CONST D2D1_PENCIL_POINT *startPoint,
        _COM_Outptr_ ID2D1PencilStroke **pencilStroke 
        ) PURE;
    
    STDMETHOD_(void, DrawPencilStroke)(
        _In_ ID2D1PencilStroke *pencilStroke,
        _In_ CONST D2D1_PENCIL_STYLE *pencilStyle,
        _In_opt_ ID2D1BitmapBrush *paperTexture1Brush,
        _In_opt_ ID2D1BitmapBrush *paperTexture2Brush,
        FLOAT stampSpacingFraction 
        ) PURE;
    
    COM_DECLSPEC_NOTHROW
    void
    DrawPencilStroke(
        _In_ ID2D1PencilStroke *pencilStroke,
        D2D1_PENCIL_STYLE pencilStyle,
        _In_opt_ ID2D1BitmapBrush *paperTexture1Brush,
        _In_opt_ ID2D1BitmapBrush *paperTexture2Brush,
        FLOAT stampSpacingFraction 
        )  
    {
        DrawPencilStroke(pencilStroke, &pencilStyle, paperTexture1Brush, paperTexture2Brush, stampSpacingFraction);
    }
}; // interface ID2D1PrivatePencilDeviceContext




// {A8C10770-57BD-4956-A38D-A0DEE34500D8}
DEFINE_GUID(GUID_InkSegmentTypeTime, 0xa8c10770, 0x57bd, 0x4956, 0xa3, 0x8d, 0xa0, 0xde, 0xe3, 0x45, 0x0, 0xd8);
// {243DA0D4-7AAA-4F46-9D60-F55B53F3EAEA}
DEFINE_GUID(GUID_InkSegmentTypePressureTilt, 0x243da0d4, 0x7aaa, 0x4f46, 0x9d, 0x60, 0xf5, 0x5b, 0x53, 0xf3, 0xea, 0xea);

interface ID2D1InkRealization;
interface ID2D1InkStrokeGroup;
                 

/// <summary>
/// Represents a single continuous stroke of ink, as defined by a series of circular
/// arc and line segments.
/// </summary>
interface DX_DECLARE_INTERFACE("25d5e6fd-7623-4aa7-8c65-33ef97906bc0") ID2D1InkStroke  : public ID2D1Resource
{
    
    STDMETHOD(GetStartPoint)(
        _Out_writes_(startPointSize) BYTE *startPoint,
        UINT32 startPointSize 
        ) CONST PURE;
    
    /// <summary>
    /// Edit segments at end of the stroke, and optionally return stroke groups
    /// containing invalid segment regions of the original and modified stroke
    /// </summary>
    STDMETHOD(EditSegmentsAtEnd)(
        UINT32 segmentCountToRemove,
        _In_reads_(segmentSize * segmentCountToAdd) CONST BYTE *segmentsToAdd,
        UINT32 segmentSize,
        UINT32 segmentCountToAdd,
        _In_reads_opt_(invalidationQueryCount) ID2D1InkRealization **realizationsForInvalidation,
        _Out_writes_opt_(invalidationQueryCount) ID2D1InkStrokeGroup **invalidationGroups,
        UINT32 invalidationQueryCount 
        ) PURE;
    
    /// <summary>
    /// Returns the number of segments the ink stroke is composed of
    /// </summary>
    STDMETHOD_(UINT32, GetSegmentCount)(
        ) CONST PURE;
    
    /// <summary>
    /// Retrieves the segments stored in the InkStroke
    /// </summary>
    STDMETHOD(GetSegments)(
        UINT32 startSegment,
        _Out_writes_(segmentSize * segmentCount) BYTE *segments,
        UINT32 segmentSize,
        UINT32 segmentCount 
        ) CONST PURE;
    
    /// <summary>
    /// Returns the GUID representing the layout of the segment point format.
    /// </summary>
    STDMETHOD_(GUID, GetStrokeFormat)(
        ) CONST PURE;
    
    /// <summary>
    /// Gets the offset from the logical beginning of the stroke.  This distance may
    /// include erased regions for which the stroke contains no segment data.
    /// </summary>
    STDMETHOD_(FLOAT, GetOffsetFromLogicalStart)(
        ) CONST PURE;
    
    /// <summary>
    /// Gets the offset from the logical end of the stroke.  This distance may include
    /// erased regions for which the stroke contains no segment data.
    /// </summary>
    STDMETHOD_(FLOAT, GetOffsetFromLogicalEnd)(
        ) CONST PURE;
}; // interface ID2D1InkStroke


/// <summary>
/// Represents a set of ink strokes which are processed and blended as a single
/// layer.  This enables point erase to change only an isolated region of pixels.
/// </summary>
interface DX_DECLARE_INTERFACE("c2a03350-0ab3-4359-9d62-2e61fa677d6d") ID2D1InkStrokeGroup  : public ID2D1Resource
{
    
    STDMETHOD(InsertStroke)(
        UINT32 index,
        _In_ ID2D1InkStroke *stroke 
        ) PURE;
    
    STDMETHOD(RemoveStroke)(
        UINT32 index 
        ) PURE;
    
    STDMETHOD_(UINT32, GetStrokeCount)(
        ) CONST PURE;
    
    STDMETHOD(GetStroke)(
        UINT32 index,
        _COM_Outptr_ ID2D1InkStroke **stroke 
        ) CONST PURE;
    
    /// <summary>
    /// Erases a region from the stroke, potentially adding a new stroke after the given
    /// stroke
    /// </summary>
    STDMETHOD(PointErase)(
        UINT32 strokeIndex,
        UINT32 startSegmentIndex,
        FLOAT startSegmentDistance,
        UINT32 endSegmentIndex,
        FLOAT endSegmentDistance,
        _Outptr_result_maybenull_ ID2D1InkStroke **newStroke 
        ) PURE;
}; // interface ID2D1InkStrokeGroup


/// <summary>
/// Used for drawing ink stroke groups through ink effects.  Ink realizations
/// contain indexing and metadata that preserves exact appearance of a stroke on an
/// effect as the stroke changes.
/// </summary>
interface DX_DECLARE_INTERFACE("0892ee43-fcc3-4f78-b551-b5f2f6b2a110") ID2D1InkRealization  : public ID2D1Resource
{
    
    /// <summary>
    /// Gets the ink stroke group that the realization was created from
    /// </summary>
    STDMETHOD_(void, GetInkStrokeGroup)(
        _Outptr_ ID2D1InkStrokeGroup **inkStrokeGroup 
        ) CONST PURE;
}; // interface ID2D1InkRealization


interface DX_DECLARE_INTERFACE("2c0c5291-eccf-46c7-bffd-f3670ddd2be9") ID2D1PrivateInkingFactory  : public IUnknown
{
    
    /// <summary>
    /// Registers a GUID representing the layout of the segment point format.  The
    /// segment format in memory is equivalent to the INK_SEGMENT_BASE structure
    /// followed by an array of FLOAT values of the specified length.
    /// </summary>
    STDMETHOD(RegisterInkStrokeFormat)(
        _In_ REFGUID guid,
        _In_ CONST UINT32 extraPointFieldCount 
        ) PURE;
    
    STDMETHOD(CreateInkStroke)(
        _In_ REFGUID strokeFormat,
        _In_ CONST D2D1_INK_STROKE_DATA *data,
        FLOAT offsetFromLogicalStart,
        FLOAT offsetFromLogicalEnd,
        _COM_Outptr_ ID2D1InkStroke **inkStroke 
        ) PURE;
    
    STDMETHOD(CreateInkStrokeGroup)(
        _In_ REFGUID strokeFormat,
        _COM_Outptr_ ID2D1InkStrokeGroup **inkStrokeGroup 
        ) PURE;
}; // interface ID2D1PrivateInkingFactory


interface DX_DECLARE_INTERFACE("efea2f86-0029-4b99-95a2-339102c4d609") ID2D1PrivateInkingDeviceContext  : public IUnknown
{
    
    STDMETHOD(CreateInkRealization)(
        _In_ ID2D1InkStrokeGroup *strokeGroup,
        _COM_Outptr_ ID2D1InkRealization **inkRealization 
        ) PURE;
    
    STDMETHOD(CreateTargetImage)(
        _COM_Outptr_ ID2D1Image **targetImage 
        ) PURE;
}; // interface ID2D1PrivateInkingDeviceContext


/// <summary>
/// An extension to ID2D1Effect which ink realizations may be set onto
/// </summary>
interface DX_DECLARE_INTERFACE("d3abd36b-9ad5-41c7-bc23-0a4dadf93315") ID2D1InkEffect  : public ID2D1Effect
{
    
    /// <summary>
    /// Sets the ink realization to draw through the effect.  The indexing and metadata
    /// within the realization is invalidated minimally as necessary when the effect it
    /// is currently set onto is drawn, or the associated ink stroke is changed.
    /// </summary>
    STDMETHOD_(void, SetInk)(
        _In_opt_ ID2D1InkRealization *ink 
        ) PURE;
    
    /// <summary>
    /// Gets the ink realization drawn through the effect
    /// </summary>
    STDMETHOD_(void, GetInk)(
        _Outptr_result_maybenull_ ID2D1InkRealization **ink 
        ) CONST PURE;
}; // interface ID2D1InkEffect



#endif

#endif // #ifndef _D2D1P_H_
